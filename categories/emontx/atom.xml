<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emontx | Blog | OpenEnergyMonitor]]></title>
  <link href="https://blog.openenergymonitor.org/categories/emontx/atom.xml" rel="self"/>
  <link href="https://blog.openenergymonitor.org/"/>
  <updated>2019-08-22T13:28:37+00:00</updated>
  <id>https://blog.openenergymonitor.org/</id>
  <author>
    <name><![CDATA[Glyn Hudson]]></name>
    <email><![CDATA[support@openenergymonitor.zendesk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ESP8266 WIFI developments]]></title>
    <link href="https://blog.openenergymonitor.org/2016/06/esp8266-emonesp-developments/"/>
    <updated>2016-06-20T10:00:00+00:00</updated>
    <id>https://blog.openenergymonitor.org/2016/06/esp8266-emonesp-developments</id>
    <content type="html"><![CDATA[<p>Glyn and I have been doing a bit of development recently on using the ESP8266 WiFi board with OpenEnergyMonitor hardware, we are quite excited about the potential of this little module to both reduce the cost of the system and simplify setup and installation especially for applications that primarily post to a remote emoncms server such as <a href="https://emoncms.org">emoncms.org</a>.</p>

<p><strong>Note:</strong> we have no plans to discontinue developments and support for Raspberry Pi based systems e.g. emonPi / emonBase. Quite the opposite: the local storage and processing of a Raspberry Pi based system has many advantages particularly for systems requiring more flexibility and customisation e.g Local Emoncms storage. MQTT, openHAB &amp; nodeRED integration. The ESP developments will be ran in parallel, in fact ESP could be configured to post to an emonPi / emonBase via MQTT for local on-site storage and integration.</p>

<p>We are at the moment working on three initial uses of the ESP8266:</p>

<h2 id="emontx-v3--esp8266-module">1. <strong>EmonTx V3</strong> + ESP8266 module</h2>

<p>We are initially using the Adafruit HUZZAH ESP8266 module as a development platform. For anyone keen to get going with the ESP8266 Huzzah module it is available from a number of places such as <a href="https://www.adafruit.com/product/2471">adafruit</a> (USA) and <a href="https://shop.pimoroni.com/products/adafruit-huzzah-esp8266-breakout">Pimoroni</a> (UK). Any ESP8266 with ESP-12 module should work the same. See lower in the post for EmonESP firmware dev.</p>

<p><img src="/images/emontx-esp.png" alt="image" /></p>

<p>There will be another post very soon detailing how to use this module with the EmonTx v3.</p>

<!--more-->

<h2 id="heatpumpenergy-monitor">2. Heatpump/Energy Monitor</h2>

<p>Heatpump / energy monitor through-hole development board, essentially and EmonTx v2 with additional features for interfacing with heat meters and multiple DS18B20 temperature sensors as well as an integrated ESP8266 WIFI module.</p>

<p><img src="/images/heatpumpmonitor.png" alt="image" /></p>

<p>The heatpump monitor board currently supports:</p>

<ul>
  <li>3x CT + ACAC Channels</li>
  <li>Elster A100C Irda meter reader (watt hours)</li>
  <li>Pulse Counting</li>
  <li>Supports MBUS heat meters (Kamstrup 402)</li>
  <li>Supports SIKA flow meters</li>
  <li>4x DS18B20 Temperature Sensors</li>
  <li>Miniature solid state relay for heating control (not yet tested)</li>
  <li>ESP8266 Low cost Wifi</li>
  <li>RFM69 option</li>
  <li>Raspberry PI connector option</li>
  <li>A Through-hole ESP Wifi development platform</li>
  <li>Fits in the EmonTx V3 Aluminum case</li>
</ul>

<p>Guide cost ~£50 (ex VAT) for full heatpump monitor kit with case, ~£30 (ex VAT) for cut down WIFI energy monitor only kit without case.. To be finalised.</p>

<p><a href="https://github.com/openenergymonitor/HeatpumpMonitor">See Heatpump monitor development repo</a></p>

<h2 id="esp8266-based-wifi-pixel-energy-display">3. ESP8266 based WIFI Pixel Energy Display,</h2>

<p>This is an idea thanks to David Hunninsett (<a href="http://twitter.com/m0untainpenguin">@m0untainpenguin</a>) with hardware being developed by <a href="https://github.com/Protoneer/WifiPixels">Protoneer</a>. It fits into a project we are more recently part of here in North Wales called <a href="http://www.energylocal.co.uk/cydynni/">CydYnni by EnergyLocal</a> where 100 households within the boundary of the substation get cheap electricity when a local community hydro is running. David Hunninsett is one of the households on the project and he is keen to have a display that shows when it’s a good time to use electricity among other uses. The wifi pixel could become a nice platform for a ambient home energy indicator.</p>

<p><img src="/images/wifi-pixel1.jpg" alt="image" /></p>

<p><img src="/images/wifi-pixel2.jpg" alt="image" /></p>

<p><a href="http://community.openenergymonitor.org/uploads/default/original/1X/c72e375230597049c0d8a9e06645a8d088d70774.mp4">See video</a></p>

<p><a href="https://github.com/davehun/mqtt-wifi-pixel">See software development  repo on</a></p>

<h1 id="emonesp-easier-setup-and-installation">EmonESP, easier setup and installation</h1>

<p>One of the really nice things about using the ESP module is that it can really simplify setup for installations that only need to post to a remote emoncms server. The wifi module starts by broadcasting a hotspot that you connect to directly, you can then scan for wifi networks, select the network, get the ip address of the monitor on the network (which saves using fing or accessing your router device list), enter your emoncms.org apikey to connect to an emoncms.org account (to be replaced with username and passowrd login + ability to register and link the monitor to a emoncms account in one step).</p>

<p><img src="/images/emonesp.jpg" alt="image" /></p>

<p>We plan to extend EmonESP to also support MQTT.</p>

<p>The EmonESP software is based on work by Chris Howel of <a href="http://www.openevse.com">OpenEVSE</a> which is a really nice open hardware electric vehicle charging station, it’s been really nice to find a common development like this that can be beneficial to two open hardware and software projects. OpenEVSE <a href="https://data.openevse.com/">already use Emoncms</a> for logging and graphing.</p>

<p><a href="https://github.com/openenergymonitor/emonesp">EmonESP firmware developments can be found on github</a></p>

<h2 id="over-the-air-firmware-upload">Over the air firmware upload</h2>

<p>Glyn has been doing a lot of work on how we can do over the air updates to ESP8266 based units. Being able to do this will make it a lot easier to maintain and keep the firmware on these updated especially as the software goes through the larger number of iterations in initial development. Check out his blog posts here to follow the development:</p>

<ul>
  <li><a href="https://blog.openenergymonitor.org/2016/06/platformio/">Part 1/3: PlatformIO open-source embedded development ecosystem</a></li>
  <li><a href="https://blog.openenergymonitor.org/2016/06/auto-build-continuous-test-firmware">Part 2/3: Firmware Continuous Test &amp; Build</a></li>
  <li>3/3: Continuous Deployment (OTA to ESP8266) <em>…In the making!</em></li>
</ul>

<h2 id="forum-discussion">Forum discussion</h2>

<p>See <a href="https://community.openenergymonitor.org/t/esp8266-wifi-developments/784">this forum topic</a> for discussion.</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Part 2/3: Firmware Continuous Test & Build]]></title>
    <link href="https://blog.openenergymonitor.org/2016/06/auto-build-continuous-test-firmware/"/>
    <updated>2016-06-14T10:00:00+00:00</updated>
    <id>https://blog.openenergymonitor.org/2016/06/auto-build-continuous-test-firmware</id>
    <content type="html"><![CDATA[<p><strong>This post is part of a series</strong></p>

<ul>
  <li><a href="/2016/06/platformio/">1/3 PlatfomIO overview &amp; compiling + uploading locally and on a Raspberry Pi</a></li>
  <li><strong>2/3: Continuous testing and auto release binary generation using PlatformIO &amp; TravisCI</strong></li>
  <li><a href="/2016/06/esp8266-ota-update/">3/3: Continuous Deployment (OTA to ESP8266)</a></li>
</ul>

<hr />

<p>Following on from the <a href="https://blog.openenergymonitor.org/2016/06/platformio/">last blog post</a> on using <a href="https://blog.openenergymonitor.org/2016/06/platformio/">PlatformIO</a> to compile and upload firmware locally, we’re now going to take things a step further and do the same but in <em>The Cloud</em>!</p>

<p><em>Groan…I know I just used the clichéd ‘C’ word, however there are many advantages to compiling and testing the code in the cloud. At least I didn’t mention ‘IoT’…whoops, just doing my bit for SEO!</em></p>

<p>In this instance when we say <em>‘compile in the cloud’</em> I mean use GitHub, <a href="https://travis-ci.org">Travis IO</a> and <a href="https://platformio.org">PlatfromIO</a> to compile the firmware and if the branch is tagged with a ‘Git Release’ auto-generate a compiled binary and upload it back to GitHub release page.</p>

<p>The motivation behind this automated-build and testing is working towards creating a robust infrastructure to push OTA updates to ESP8266 connected nodes (<a href="https://github.com/openenergymonitor/EmonESP">EmonESP dev</a>) inspired by <a href="http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html">this blog post</a> by Daniel Eichhorn (<a href="https://twitter.com/squix78">@squix78</a>).</p>

<!--more-->

<p>The advantages of <a href="https://en.wikipedia.org/wiki/Continuous_testing">continuous testing</a> have been long established in the software industry. The test we are performing is <em>‘does this firmware compile?’</em>; obviously this is not a comprehensive test but it will at least give us confidence that there are no syntax errors etc. To actually test operation of embedded firmware, physical hardware (or simulation) would be required.</p>

<h2 id="how-it-works">How it works</h2>

<ul>
  <li>A commit or pull request is made to the firmware repository on GitHub
    <ul>
      <li><em>To date emonPi, emonTx and EmonESP repositories have been enabled for continuous build &amp; test</em></li>
    </ul>
  </li>
  <li>
    <p>This triggers Travis CI to start a ‘build’</p>
  </li>
  <li>Code compilation is generated using platformIO in the same way as when compiling locally, <a href="https://blog.openenergymonitor.org/2016/06/platformio/">See blog post</a>. The <a href="https://github.com/openenergymonitor/emonpi/blob/master/.travis.yml"><code class="highlighter-rouge">.travis.yml</code> file in the repo</a> configures the Travis CI build using platformIO:</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>language: python
python:
- '2.7'
sudo: false
cache:
  directories:
  - "~/.platformio"
install:
- pip install -U platformio
script:
- platformio run -d firmware -e emonpi_deploy
deploy:
  on:
    repo: openenergymonitor/emonpi
    all_branches: true
    condition: $TRAVIS_TAG =~ ^[0-9]+\.[0-9]+\.[0-9]+$
  skip_cleanup: true
  provider: releases
  overwrite: true
  api_key:
    secure: OzNwxsQEVlSj2e4sOqKNYlNXqPqc5myL0nOBtY1FYD+sbxslHMixmlRASWuFMCjHdpFYQST2IuR3UMCPCjfPzMDVCVtsJ8VPd299fgDGzmEnL3P5Z8wCAv1CfHURcfXzFJDM7prevGx9cfz8uAiwIaNOhbTL7kL2GfSatV5PERzr2ytVh6WUj650Rd7bLKKhj8YHOzO9wOBoKDadYDFF99XYQbDDoHj9pAv+OPG76X0kWrdrq/0w26jh7JZaxrwhF/xD7maGaEjLOa/FcXbyZlVy/JIFjyrKp79swzVNSFNox/CbF7e6tzBf3NhZsoQyEchnCrgWw8IB7j/Ja7Ypetn6IG7C5rT/h46rWrZshbVdw7ZBUzhNJIUVLHFBy7hi2hxMw9Bn+oCt0UWLt8SnQnRfAbjw+z3XQ2/6MccUAINKGDqd4fm9M85sN6drpXySeJ/ZyRkdlUN0xsDpARI05mYLLlCutRzlSCkglbsKJr5XM7h7pXHLUQY5dfw9LrA788w25OBoO9U8vCKtoV8UCXWh6og/364CRl9Uih958f1t7kHIvfwLJjwSDFYVxUsyvSFyjfY+pIfuGEXtgIqMZ87nK3O1vAb9udbPErp0q5kJBeks9Df6wVsvjI7O++7YwiSuWlJBD0x45ZV9pxOFLnWb1hetHpPH5kFgBlTDqsY=
  file: "firmware/.pioenvs/emonpi_deploy/firmware.hex"
</code></pre>
</div>

<ul>
  <li>If the build fails for whatever reason (syntax error, library error etc) then the green <code class="highlighter-rouge">build passing</code> icon changes to a ominous red <code class="highlighter-rouge">build Failed</code> and we get an alert email. For a full build log example see the <a href="https://travis-ci.org/openenergymonitor/emonpi">emonPi Travis CI build page</a>.</li>
</ul>

<p><a href="https://travis-ci.org/openenergymonitor/emonpi"><img src="https://travis-ci.org/openenergymonitor/emonpi.svg?branch=master" alt="Build Status" /></a></p>

<ul>
  <li>If the GitHub branch is tagged with a ‘release tag’ and compilation is successful then the generated <code class="highlighter-rouge">.hex</code> or <code class="highlighter-rouge">.bin</code> is uploaded to the GitHub release page:</li>
</ul>

<p><img src="/images/emonpi-draft-release.png" alt="image" /></p>

<p><img src="/images/emonpi-travis-release.png" alt="image" /></p>

<p>For a detailed explanation of how the release binary is generated and deployed see Daniel Eichhorn’s (<a href="https://twitter.com/squix78">@squix78</a>) <a href="http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html">excellent blog post</a>.</p>

<hr />

<p>Stay tuned for part 3/3 of the PlatformIO firmware work-flow post series, which will cover auto deploying (OTA) the compiled firmware release onto an ESP8266. For a sneak peak checkout <a href="http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html">this excellent blog post</a> which was a source of inspiration and information.</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Part 1/3: PlatformIO open-source embedded development ecosystem]]></title>
    <link href="https://blog.openenergymonitor.org/2016/06/platformio/"/>
    <updated>2016-06-12T10:00:00+00:00</updated>
    <id>https://blog.openenergymonitor.org/2016/06/platformio</id>
    <content type="html"><![CDATA[<p><strong>This post is part of a series:</strong></p>

<ul>
  <li><strong>1/3: PlatfomIO overview &amp; compiling + uploading locally and on a Raspberry Pi</strong></li>
  <li><a href="/2016/06/auto-build-continuous-test-firmware/">2/3: Continuous testing and auto release binary generation using PlatformIO &amp; TravisCI</a>
    <ul>
      <li>Related post: <a href="/2016/06/esp8266-emonesp-developments">EmonESP ESP8266 WiFi developments</a></li>
    </ul>
  </li>
  <li><a href="/2016/06/esp8266-ota-update/">3/3: Continuous Deployment (OTA to ESP8266)</a></li>
</ul>

<hr />

<h1 id="part-13-platformio-open-source-embedded-development-ecosystem">Part 1/3: PlatformIO open-source embedded development ecosystem</h1>

<p>Getting an Arduino based project (or other embedded platform) to compile and upload can be a pain. Making sure all the libraries are installed in the correct locations and of the correct versions can be tricky and time-consuming.</p>

<p>I’m sure many developers will agree that the tools we use for embedded development are generally not as good as those used for web application development.</p>

<p>The Arduino team have done a good job with their IDE to try and make the embedded development tool-chain setup as easy as possible. However, I still find library management a cause of frustration. Especially since I move between computers and OSes frequently.</p>

<p>Recently I have been using PlatformIO and am rather impressed with the ease of setup, speed of compilation, uploading (auto port detection), and most importantly an excellent <a href="http://platformio.org/lib">library manager</a>.</p>

<blockquote>
  <p>PlatformIO is an open-source ecosystem for IoT development.</p>
</blockquote>

<blockquote>
  <p>Cross-platform build system, IDE integration and continuous testing. Arduino, Espressif, ARM and mbed compatible.</p>
</blockquote>

<p><img src="/uploads/default/original/1X/f6d5f19402b36b099b3d54bd44a46b2a1ce673d3.png" alt="PlatformIO IDE" /></p>

<p>This post got quite long, therefore, It’s been split into three posts:</p>

<ol>
  <li>PlatfomIO overview &amp; compiling + uploading locally and on a Raspberry Pi</li>
  <li>Continuous testing and auto release binary generation using PlatformIO &amp; TravisCI</li>
  <li>Continuous Deployment (OTA to ESP8266)</li>
</ol>

<p>Here are some things that have impressed me about PlatformIO (pio) after using it for a couple of weeks:</p>

<ul>
  <li><a href="https://github.com/platformio"><strong>Fully open-source</strong></a> with active and friendly dev community.</li>
  <li><strong>Easy to install</strong> - Pure python based installed using pip
    <ul>
      <li>Tool-chains are auto installed on first compile / upload e.g.
        <ul>
          <li>If trying to upload to Arduino avrdude will automatically be installed</li>
          <li>If trying to compile an ESP8266 project the ESP toolchain will be installed</li>
        </ul>
      </li>
      <li>Cross-platform (Linux, Windows and mac all work the same), this will make support much easier</li>
    </ul>
  </li>
  <li><strong>Supports all the main embedded platforms</strong>
    <ul>
      <li>atmelavr (Arduino), espressif (ESP8266), ststm32 (ARM etc.)</li>
    </ul>
  </li>
  <li><strong>Command line and IDE</strong>
    <ul>
      <li>At work I use pio via Atom IDE on Ubuntu</li>
      <li>At home, I use a Chromebook with Caret IDE and interact with pio via command-line</li>
      <li>When developing directly on an emonPi / RaspberryPi pio command-line works great - <em>Yes, that’s right pio works on a RaspberryPi to compile and upload code directly!</em></li>
    </ul>
  </li>
  <li><a href="http://platformio.org/lib"><strong>Excellent library manager</strong></a>
    <ul>
      <li>Libraries can be searched and reviewed using command-line or web 2.0 manager</li>
      <li>Required libraries can be specified in the <code class="highlighter-rouge">platformio.ini</code> file and if not present install is prompted upon compilation</li>
      <li>Specific library version (as defined in <code class="highlighter-rouge">library.json</code> <a href="https://github.com/openenergymonitor/EmonLib/blob/master/library.json">(emonLib example)</a>) or git commit SHA</li>
    </ul>
  </li>
  <li><strong>Fast compilation &amp; pain-free uploading</strong>
    <ul>
      <li>PlatformIO’s compiler is the <a href="https://twitter.com/krzychb2/status/729294573760065536">fastest in the business</a></li>
      <li>USB / Serial ports auto detected</li>
      <li>Since the emonPi has been added as a custom board PlatformIO can even upload direct to emonPi via RaspberryPi GPIO and trigger GPIO AVR reset, not more <a href="https://github.com/openenergymonitor/avrdude-rpi">hacked avrdude</a>.</li>
    </ul>
  </li>
  <li><strong>Easy integration with continuous testing &amp; deployment</strong>
    <ul>
      <li>Integration with TravisCI to enable compilation, code testing and binary (.hex / .bin) release generation in the cloud.</li>
      <li><a href="http://github.com/openenergymonitor/emonpi/">emonPi</a> and <a href="github.com/openenergymonitor/emonTxFirmware">emonTx</a> git repos are now enabled for continous-testing and auto binary generation on release tag…this is a step change in embedded development.</li>
    </ul>
  </li>
</ul>

<!--more-->

<hr />

<h2 id="example-compiling-emontx--emonpi-firmware">Example: Compiling emonTx / emonPi firmware</h2>

<p><a href="http://docs.platformio.org/en/latest/quickstart.html">PlatformIO has some excellent quick start docs</a> to cover setting up your first ‘blinky’ project, therefore I will not duplicate here. In this example I focus on setting up pio and compiling emonTx / emonPi firmware. This example assumes a totally bare metal machine with nothing installed except python (2.7 recommended). Pio works great on a Raspberry Pi.</p>

<p>This guide used command-line steps on Linux, if using windows or if you want to use the platformio IDE see <a href="http://platformio.org/get-started">PlatformIO Getting Started Page</a>.</p>

<p>The PlatformIO IDE or Atom IDE is excellent and very easy to use (self explanatory). This guide uses pio via command line as this gives a more hands-on experience to how pio is working.</p>

<h3 id="install-platformio">1. Install PlatformIO</h3>

<p>The easiest way if running Linux is to install use the install script, this installed pio via python pip and installs pip if not present. See <a href="http://docs.platformio.org/en/latest/installation.html#installer-script">PlatformIO installation docs</a>:</p>

<p><code class="highlighter-rouge">$ sudo python -c "$(curl -fsSL https://raw.githubusercontent.com/platformio/platformio/master/scripts/get-platformio.py)"</code></p>

<h3 id="clone-emontx--emonpi-repo">2. Clone emonTx / emonPi repo</h3>

<p>We’ll use the emonTx (V3 discrete sampling) as an example here but the steps are exactly the same for emonPi.</p>

<p><strong>emonTx V3</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ git clone https://github.com/openenergymonitor/emontx3`
$ cd emontx3/firmware
</code></pre>
</div>

<p><strong>emonPi</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ git clone https://github.com/openenergymonitor/emonpi`
cd emonpi/firmware
</code></pre>
</div>

<h3 id="compile-with-platformio">3. Compile with PlatformIO</h3>

<p><code class="highlighter-rouge">$ platformio run</code></p>

<p>or shorthand for the lazy</p>

<p><code class="highlighter-rouge">$ pio run</code></p>

<p><strong>That’s it!</strong> That’s all that’s needed to setup pio from scratch and compile emonTx firmware :-D</p>

<p>The first time platformIO is run it will ask to install the required libraries (at the specific version) and avr toolchain. The required libraries are defined in <a href="https://github.com/openenergymonitor/emontx3"><code class="highlighter-rouge">platformio.ini</code> in the emonTx discrete sampling firmware folder</a>:</p>

<p>e.g.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>lib_deps =
  DallasTemperature @3.7.7
  EmonLib
  JeeLib@c057b5f4c0
</code></pre>
</div>
<p>Libs version can be defined by github commit ID, version number (git tag) or latest version (no specific version specified.)</p>

<p>The latest version of the libraries are automatically cloned from their native git repos into the <code class="highlighter-rouge">.piolibdeps</code> folder in the project dir.</p>

<h3 id="upload-using-platformio">3. Upload using PlatformIO</h3>

<h4 id="a-via-usb-to-uart-programmer-to-emontx">3a. Via USB to UART programmer to emonTx</h4>

<p><code class="highlighter-rouge">$ sudo pio run -t upload</code></p>

<p>Pio will attempt to auto detect the USB programmer and upload :-)</p>

<p><em>Note: you will need <code class="highlighter-rouge">sudo</code> unless you have correctly <a href="https://github.com/platformio/platformio/blob/develop/scripts/99-platformio-udev.rules">configured udev rules</a>.</em></p>

<p>There is even a built in serial monitor</p>

<p><code class="highlighter-rouge">$ pio device monitor</code></p>

<h3 id="b-using-ttyama0-gpio-to-upload-direct-to-emonpi">3b. Using ttyAMA0 GPIO to upload direct to emonPi</h3>

<p>This is where things get very exciting, pio can compile the code directly on a Raspberry Pi. The latest version of pio (due to be released in the next few weeks) will have built in support for the emonPi auto-reset on upload using GPIO4</p>

<p>The emonPi board is defined in <code class="highlighter-rouge">platformio.ini</code> in the <a href="https://github.com/openenergymonitor/emonpi/blob/master/firmware/platformio.ini">emonpi/firmware folder</a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>board = emonpi
upload_port = /dev/ttyAMA0
</code></pre>
</div>

<p>All that is needed to compile and upload directly on the emonPi is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd ~/emonpi/firmware
$ sudo pio run -t upload
</code></pre>
</div>

<p><em>Thanks a lot to <a href="https://github.com/ivankravets">Ivan Kravets</a> for helping integrate emonPi into the PlatfomIO ecosystem. <a href="https://github.com/platformio/platformio/commit/c5b5e80de4928cf91be59e675429b520e31d873a">View commit changes</a></em></p>

<hr />
<p>Stay tuned for part 2/3 of the PlatformIO post series which will cover setting up firmware continuous testing using Travis CI and auto compiled binary generation on release tag directly on github. This is currently live on the emonPi &amp; emonTx repos if you want a sneak preview. See <a href="https://github.com/openenergymonitor/emonpi/blob/master/.travis.yml">travis.yaml</a> file and Travis build status icon on the main emonpi repo <a href="https://github.com/openenergymonitor/emonpi/blob/master/README.md">Readme.md</a>.</p>

<hr />
]]></content>
  </entry>
  
</feed>
