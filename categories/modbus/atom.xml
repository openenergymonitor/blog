<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: modbus | Blog | OpenEnergyMonitor]]></title>
  <link href="https://blog.openenergymonitor.org/categories/modbus/atom.xml" rel="self"/>
  <link href="https://blog.openenergymonitor.org/"/>
  <updated>2022-04-12T16:21:24+00:00</updated>
  <id>https://blog.openenergymonitor.org/</id>
  <author>
    <name><![CDATA[Glyn Hudson]]></name>
    <email><![CDATA[support@openenergymonitor.zendesk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[From the Forum: Using Modbus RS485 to read a SDM630M 3-phase meter ]]></title>
    <link href="https://blog.openenergymonitor.org/2014/09/from-forum-using-modbus-rs485-to-read/"/>
    <updated>2014-09-11T11:20:00+00:00</updated>
    <id>https://blog.openenergymonitor.org/2014/09/from-forum-using-modbus-rs485-to-read</id>
    <content type="html"><![CDATA[<div><br /></div>
<div><a href="http://openenergymonitor.org/emon/user/1332">JBecker</a> writes :</div>
<div><br /></div>
<div><div>I am using a modified OpenEnergyMonitor energy monitoring hardware since more than a year now, with one voltage sensor and three CTs for the current measurement of the three mains phases. This system logs via the RFM12 and a Jeelink USB dongle to Emoncms on a Windows Home Server. This setup is running very reliably with an accuracy of better than ~4% compared to my power meter. I think it would be possible to get better accuracy by using individual voltage sensors on all phases.</div><div><br /></div><div>In Germany the majority of household have three phase supply. To be able to use three voltage sensors it would be necessary to have three outlets within the distribution (for non-invasive mounting). I have never seen that. This means that you have to ask a friendly electrician to install these outlets. But then the whole thing is not really 'non-invasive' any more (and the OEM solutions becomes quite complex with a lot of cabling). This is a dilemma which is hard to solve.</div><div><br /></div><div>So I came to another solution which is quite simple and uses mostly ready-made components:</div><div><br /></div><div>I am using Chinese 3-phase energy monitors since some time for professional purposes (PV-Systems with battery storage). A very nice unit of this type is the <a href="http://bg-etech.de/os/product_info.php?products_id=50">Eastron SDM630M</a>. This device has integrated shunts for current measurement, a nice little display and an RS485 interface for data readout with Modbus protocol. A lot of measuring values can be read, including imported and exported energy, phase voltages, currents, frequency, reactive power and so on. Parameters for the RS485 can also be set via four small keys and the display.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Guaw2kl_rPI/VBF8gtI9gmI/AAAAAAAA7fU/5iWTZ7z1cvA/s1600/P1030829.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-Guaw2kl_rPI/VBF8gtI9gmI/AAAAAAAA7fU/5iWTZ7z1cvA/s1600/P1030829.JPG" height="320" width="291" /></a></div><div><br /></div><div><br /></div><div>For data storage and visualization I decided use the new Emoncms 'low-write' version on a Raspberry Pi. This was installed according to the installation instructions and worked 'out-of-the-box'. The only thing missing on the RasbPi for direct connection to the SDM630 is an RS485 interface.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-jgtDxANgmBg/VBF8jzNsIgI/AAAAAAAA7fc/dcjhu0OQG7o/s1600/P1030830.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-jgtDxANgmBg/VBF8jzNsIgI/AAAAAAAA7fc/dcjhu0OQG7o/s1600/P1030830.JPG" height="240" width="320" /></a></div><div><br /></div><div><br /></div><div>To be able to use the already existing software for data collection on the RasPi (Emonhub), I simply made a 'clone' of the RFM12Pi module. This now has an RS485 driver onboard instead of the RFM12 RF transceiver. Software on the RS485Pi board is the Opti-bootloader (same as on RFM12Pi) for Arduino compatibility and a small sketch for data readout via modbus. As the only available hardware UART is already used for communication with the RasbPi I had to use a software serial for the RS485 interface. (The 'ModbusMasterSoft' library I use is a dirty hack of the existing ModbusMaster library and the AltSoftSerial library. I found no decent way to make these two work together, so I had to modify them)</div><div><br /></div><div>So the whole installation now consists of:</div><div><br /></div><div>- a Raspberry Pi with power supply and the RS485Pi interface board</div><div><br /></div><div>- the SDM630 energy meter</div><div><br /></div><div>(- and a cable in between :-))</div></div>
<div><br /></div>
<div>See forum thread for schematic and code:&nbsp;<a href="http://openenergymonitor.org/emon/node/5743">http://openenergymonitor.org/emon/node/5743</a></div>
<div><br /></div>
<div><br /></div>
<div><script class="&quot;brush:" csharp="" quot="" type="&quot;syntaxhighlighter&quot;">  Written by Joerg Becker    uses code from:   - ModbusMaster library   - AltSoftSerial library    - pezibaer (SDM630M-DC thread in www.photovoltaikforum.com)      hardware 'cloned' from:   - RFM12Pi (OpenEnergyMonitor, mharazinov)   - 3V3 RS485 driver added   - bootloader compatible to RFM12Pi      ModbusMasterSoft is a dirty hack I made by combining the ModbusMaster library and the    AltSoftSerial library. I was unable to combine these two in a decent way.   The software serial is used for the RS485, hardware serial for Raspberry Pi connection */  #include &lt;AltSoftSerial.h&gt; #include &lt;ModbusMasterSoft.h&gt;  // settings for RS485 bus (SDM630M can be configured to different values!) #define _SDM630M_MODBUS_ID  4    // Modbus address of SD630M energy monitor #define _MODBUS_BAUD     9600    // Modbus (RS485) baud rate  // settings for communication with Raspberry Pi #define _INTERVAL          10    // send interval (s) to Raspberry Pi (running EmonCMS) #define _RASPI_BAUD      9600    // UART baud rate   // some hardware definitions #define LED1_PIN           A0    // RS485 activity LED #define LED2_PIN           A1    // UART activity LED  //AltSoftSerial AltSerial; // not needed here, done in ModbusMasterSoft  // instantiate ModbusMaster object  ModbusMasterSoft node(_SDM630M_MODBUS_ID);  // float calculations are slow, but here we have enough processing time float v1,v2,v3; float i1,i2,i3; float p1,p2,p3,pa; float v1_sum,v2_sum,v3_sum; float v1_avg,v2_avg,v3_avg; float i1_sum,i2_sum,i3_sum; float i1_avg,i2_avg,i3_avg; float p1_sum,p2_sum,p3_sum,pa_sum; float p1_avg,p2_avg,p3_avg,pa_avg; uint32_t timeout;   void setup() {    pinMode(LED1_PIN, OUTPUT);    pinMode(LED2_PIN, OUTPUT);    digitalWrite(LED1_PIN, 0);    digitalWrite(LED2_PIN, 0);        Serial.begin(_RASPI_BAUD);    Serial.println("SDM630M Test Program");    delay(1000);     // initialize Modbus communication baud rate    node.begin(_MODBUS_BAUD);        timeout = millis(); }  void loop()  {    static uint8_t interval = 0;    uint8_t  result;      uint32_t tmpL;     tmpL = millis();                 if( (tmpL-timeout)&gt;=1000 )  // do this every second    {       timeout = tmpL;        digitalWrite(LED1_PIN, 1);         digitalWrite(LED2_PIN, 0);           ReadVoltages();       v1_sum += v1;       v2_sum += v2;       v3_sum += v3;        ReadCurrents();       i1_sum += i1;       i2_sum += i2;       i3_sum += i3;        ReadPowers();       p1_sum += p1;       p2_sum += p2;       p3_sum += p3;       pa_sum += pa;       if( ++interval&gt;=_INTERVAL )       {          interval = 0;          v1_avg = v1_sum*10/_INTERVAL;  // preserve one (of two) decimal digit(s)          v2_avg = v2_sum*10/_INTERVAL;          v3_avg = v3_sum*10/_INTERVAL;          v1_sum = v2_sum = v3_sum = 0;          i1_avg = i1_sum/_INTERVAL;          i2_avg = i2_sum/_INTERVAL;          i3_avg = i3_sum/_INTERVAL;          i1_sum = i2_sum = i3_sum = 0;          p1_avg = p1_sum/_INTERVAL;          p2_avg = p2_sum/_INTERVAL;          p3_avg = p3_sum/_INTERVAL;          pa_avg = pa_sum/_INTERVAL;          p1_sum = p2_sum = p3_sum = pa_sum = 0;          digitalWrite(LED2_PIN, 1);          PrintJeelink();       }       digitalWrite(LED1_PIN, 0);    } }  void PrintJeelink(void) {    unsigned char i;    union DATA    {       unsigned char item[];       struct       {          int P1;          int P2;          int P3;          int V1;          int V2;          int V3;       } val;    } data;           data.val.P1 = (int)(p1_avg+0.5);    data.val.P2 = (int)(p2_avg+0.5);    data.val.P3 = (int)(p3_avg+0.5);    data.val.V1 = (int)(v1_avg+0.5);    data.val.V2 = (int)(v2_avg+0.5);    data.val.V3 = (int)(v3_avg+0.5);       Serial.print(" 10");              // this is data from 'node' number 10    for(i=0;i&lt;sizeof(data.val);i++)    {      Serial.print(" ");      Serial.print(data.item[i]);    }    Serial.println(); }  uint8_t ReadVoltages( void ) {    uint8_t  result;    uint32_t val;        result = node.readInputRegisters(0x0000, 6);  // read Modbus registers 0 to 5    if (result == node.ku8MBSuccess)     {       val = ((uint32_t)node.getResponseBuffer(0))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(1));       memcpy(&amp;v1, &amp;val, 4);       val = ((uint32_t)node.getResponseBuffer(2))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(3));       memcpy(&amp;v2, &amp;val, 4);       val = ((uint32_t)node.getResponseBuffer(4))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(5));       memcpy(&amp;v3, &amp;val, 4);    }       return result; }  uint8_t ReadCurrents( void ) {    uint8_t  result;    uint32_t val;        result = node.readInputRegisters(0x0006, 6);  // read Modbus registers 6 to 11    if (result == node.ku8MBSuccess)     {       val = ((uint32_t)node.getResponseBuffer(0))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(1));       memcpy(&amp;i1, &amp;val, 4);       val = ((uint32_t)node.getResponseBuffer(2))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(3));       memcpy(&amp;i2, &amp;val, 4);       val = ((uint32_t)node.getResponseBuffer(4))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(5));       memcpy(&amp;i3, &amp;val, 4);    }       return result; }  uint8_t ReadPowers( void ) {    uint8_t  result;    uint32_t val;        result = node.readInputRegisters(0x000C, 6);  // read Modbus registers 12 to 17    if (result == node.ku8MBSuccess)     {       val = ((uint32_t)node.getResponseBuffer(0))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(1));       memcpy(&amp;p1, &amp;val, 4);       val = ((uint32_t)node.getResponseBuffer(2))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(3));       memcpy(&amp;p2, &amp;val, 4);       val = ((uint32_t)node.getResponseBuffer(4))&lt;&lt;16 |((uint32_t)node.getResponseBuffer(5));       memcpy(&amp;p3, &amp;val, 4);    }       return result; } ]]></script></div>
<div><br /></div>
]]></content>
  </entry>
  
</feed>
